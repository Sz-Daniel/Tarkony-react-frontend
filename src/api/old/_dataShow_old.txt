________________________First version of fetching into data: 

   const [categoryList, setCategoryList] = useState<CategoryType[]>([])
    const [shortItemsList,setShortItemsList] = useState<ShortItemType[]>([])
    const shortItemIniResult = useQuery({
      queryKey: ['shortItemIni'],
      queryFn: () => fetchShortItems(),
      staleTime: 1000 * 60 * 60* 24, // daily
    });

    useEffect(()=>{
      if (shortItemIniResult.isLoading) console.log("shortItemIniResult Loading");
      if (shortItemIniResult.isError) console.log("shortItemIniResult Error");
      if (shortItemIniResult.isSuccess && shortItemIniResult.data) {
        console.log("shortItemIniResult", shortItemIniResult.data);
        setShortItemsList(shortItemIniResult.data);
      }
    },[shortItemsList]);

    const categoryIniResult = useQuery({
      queryKey: ['categoryIni'],
      queryFn: () => fetchCategoryList(),
      staleTime: 1000 * 60 * 60* 24, // daily
    });
  
    useEffect(()=>{
    if (categoryIniResult.isLoading) console.log("categoryIniResult Loading");
    if (categoryIniResult.isError) console.log("categoryIniResult Error");
    if (categoryIniResult.isSuccess && categoryIniResult.data) {
      console.log("categoryIniResult", categoryIniResult.data);     
    }
  },[categoryIniResult])
 */

__________________Second version of fetching into data: 

  const categoryresult = useQuery({
    queryKey: [categoriesQuery.name],
    queryFn: () => fetchGQLwQuery(categoriesQuery.query),
    staleTime: STALE_TIME_WEEKLY
  });

  useEffect(()=>{
    const { data, isLoading, isError, isSuccess } = categoryresult;
    if (isLoading) console.log(categoriesQuery.name,"Loading");
    if (isError) console.log(categoriesQuery.name,"Error");
    if (isSuccess && data) {
      console.log(categoriesQuery.name, data);  
      setCategoryList(data.data.handbookCategories);
      
    }  
  },[categoryresult.data])


  const shortItemsresult = useQuery({
    queryKey: [shortItemsListQuery.name],
    queryFn: () => fetchGQLwQuery(shortItemsListQuery.query),
    staleTime: STALE_TIME_WEEKLY
  });

  useEffect(()=>{
    const { data, isLoading, isError, isSuccess } = shortItemsresult;
    if (isLoading) console.log(shortItemsListQuery.name,"Loading");
    if (isError) console.log(shortItemsListQuery.name,"Error");
    if (isSuccess && data) {
      const shortcut =  Object.values(data.data)[0];
      console.log("TEST", shortItemsListQuery.name, shortcut);  
      setShortItemList(shortItemsListAdapter(data.data.items));
      
    }  
  },[shortItemsresult.data])

 __________________Third Version

  const[categoryList, setCategoryList] = useState<CategoryMapType[]>([])
  const[shortItemsList,setShortItemList] = useState<ItemsType<ShortItemType>[]>([])
      
    useFetchintoState<ItemsType<ShortItemType>[],ItemsType<ShortItemQueryType>[]>
    (shortItemsListQuery,
    setShortItemList,
    shortItemsListAdapter)


    useEffect(()=>{
    console.log("shortItemsList",shortItemsList);
    },[shortItemsList])

  /* Category list */
      useFetchintoState<HandbookCategoriesType<CategoryMapType>[]>
    (categoriesQuery,
      setCategoryList,
      )  
  
    React.useEffect(()=>{
   console.log("categoryList",categoryList);
    },[categoryList])


    //Dinamic fetch data into state. 
//Optional: if it's need an adapter for state
export function useFetchintoState<T, A = T>( 
    query: QueryType,
    setStateVariable:  React.Dispatch<React.SetStateAction<T>>,
    adapterToState?: (data: A) => T,
    ) {

    const result = useQuery({
        queryKey: [`${query.name}`],
        queryFn: () => fetchGQLwQuery(query.query),
        staleTime: 1000 * 60 * 60 * 24 // daily
        
    });

    useEffect(()=>{
        const { data, isLoading, isError, isSuccess } = result;
        if (isLoading) console.log(`${query.name}`,"Loading");
        if (isError) console.log(`${query.name}`,"Error");
        if (isSuccess && data) {
            console.log(`${query.name}`, data);
            //Data structure was data.data.items or data.data.category 
            //and this way I can skip the data.data
            const path: any =  Object.values(data.data)[0];
            if (adapterToState) {
                setStateVariable(adapterToState(path));
            } else {
                setStateVariable(path);
            }
        }
    },[result.data])
}


/**
Suggested, but not used still
1. A jelenlegi adatstrukt√∫ra r√∂vid √°ttekint√©se
A CategoryType egy lapos t√∂mb eleme, ahol minden elem ismeri a saj√°t normalizedName mez≈ëj√©t, valamint:

egy parent-et, ami szint√©n csak normalizedName-et tartalmaz,

√©s egy children t√∂mb√∂t, ami normalizedName-eket tartalmaz.

Ez azt jelenti, hogy nem fa, hanem gr√°f jelleg≈± strukt√∫ra (a kapcsolatok csak normalizedName mez≈ëkkel t√∂rt√©nnek), teh√°t nem be√°gyazott, hanem hivatkoz√°sos strukt√∫ra.

2. C√©l: fa szerkezet l√©trehoz√°sa
Az adapter √∂tlet kifejezetten j√≥: ha egyszer a normalizedName mez≈ëk alapj√°n l√©trehozzuk a fa strukt√∫r√°t, akkor a komponens oldalon sokkal tiszt√°bban, reakt√≠van lehet navig√°lni szintek k√∂z√∂tt.

üîß Adapter l√©trehoz√°sa
K√©sz√≠ts√ºnk egy adapter f√ºggv√©nyt, ami a bej√∂v≈ë CategoryType[] t√∂mbb≈ël val√≥di f√°t k√©sz√≠t. Ehhez sz√ºks√©ges:

egy gyors lookup map, ami normalizedName -> CategoryType referencia,

a parent-child kapcsolatok ki√©p√≠t√©se,

a gy√∂k√©r(ek) megtal√°l√°sa.

ts
M√°sol√°s
Szerkeszt√©s
type CategoryTreeNode = CategoryType & {
    children: CategoryTreeNode[]
}

export function buildCategoryTree(categories: CategoryType[]): CategoryTreeNode[] {
    const lookup = new Map<string, CategoryTreeNode>();

    // els≈ë k√∂rben √°tm√°soljuk az adatokat, de √ºres children t√∂mb√∂kkel
    categories.forEach(cat => {
        lookup.set(cat.normalizedName, {
            ...cat,
            children: [] // itt val√≥s children lesz, nem normalizedName
        });
    });

    const roots: CategoryTreeNode[] = [];

    for (const cat of categories) {
        const node = lookup.get(cat.normalizedName);
        const parentNorm = cat.parent?.normalizedName;
        if (parentNorm && lookup.has(parentNorm)) {
            const parent = lookup.get(parentNorm)!;
            parent.children.push(node!);
        } else {
            roots.push(node!); // ha nincs parent vagy nem tal√°lhat√≥, akkor gy√∂k√©r
        }
    }

    return roots;
}
Ez a f√ºggv√©ny a backend-t≈ël √©rkez≈ë CategoryType[] alapj√°n l√©trehoz egy be√°gyazott fastrukt√∫r√°t CategoryTreeNode[] form√°j√°ban, ahol az id, name stb. mez≈ëk megmaradnak, viszont children m√°r val√≥ban kateg√≥ria objektumokat tartalmaz.

3. Komponens oldali v√°ltoz√°sok ‚Äì szint alap√∫ navig√°ci√≥
A CategoryMenu komponensben ezut√°n nem normalizedName list√°val kell dolgoznunk, hanem egy kiv√°lasztott √∫tvonalat kell tartanunk ‚Äì teh√°t nem selectedCategory: string[], hanem:

ts
M√°sol√°s
Szerkeszt√©s
selectedCategoryPath: string[] // pl.: ['electronics', 'phones', 'android']
Ez alapj√°n mindig tudjuk, hogy hol tartunk a f√°ban ‚Äì a selectedCategoryPath utols√≥ eleme mutatja a jelenlegi kateg√≥ri√°t, √©s ennek children-jeit akarjuk kilist√°zni. Az egy szinttel feljebb l√©p√©shez egyszer≈±en lev√°gunk egy elemet a t√∂mb v√©g√©r≈ël.

4. Komponens friss implement√°ci√≥s logika (r√©szlet)
tsx
M√°sol√°s
Szerkeszt√©s
export function CategoryMenu({ selectedCategoryPath, setSelectedCategoryPath }: {
  selectedCategoryPath: string[],
  setSelectedCategoryPath: (path: string[]) => void
}) {
    const queryClient = useQueryClient();
    const rawCategories: CategoryType[] = queryClient.getQueryData([categoriesQuery.name]) ?? [];

    const tree = buildCategoryTree(rawCategories);

    // keresd meg a jelenlegi szintet, az √∫tvonal alapj√°n
    const findNodeByPath = (tree: CategoryTreeNode[], path: string[]): CategoryTreeNode | null => {
        let current: CategoryTreeNode | undefined;
        let nodes = tree;
        for (const name of path) {
            current = nodes.find(n => n.normalizedName === name);
            if (!current) return null;
            nodes = current.children;
        }
        return current ?? null;
    }

    const currentNode = findNodeByPath(tree, selectedCategoryPath);
    const children = currentNode?.children ?? tree; // ha nincs path, akkor gy√∂kerek

    const handleForward = (nextNorm: string) => {
        setSelectedCategoryPath([...selectedCategoryPath, nextNorm]);
    }

    const handleBack = () => {
        if (selectedCategoryPath.length > 0) {
            setSelectedCategoryPath(selectedCategoryPath.slice(0, -1));
        }
    }

    return (
        <>
            {selectedCategoryPath.length > 0 && (
                <Chip label="‚¨Ö Vissza" onClick={handleBack} />
            )}

            {children.sort((a, b) => a.name.localeCompare(b.name)).map((cat) => (
                <Chip key={cat.id} label={cat.name} onClick={() => handleForward(cat.normalizedName)} />
            ))}
        </>
    )
}
Ez m√°r reakt√≠v, szintalap√∫ megjelen√≠t√©st biztos√≠t, √©s a kiv√°lasztott kateg√≥ria alapj√°n l√©ptethet≈ë oda-vissza. K√∂zben nem sz√ºks√©ges flat m√≥don gy≈±jt√∂getni a lesz√°rmazottakat, hanem mindig csak a k√∂vetkez≈ë szint √©rdekes.

5. Tov√°bbi lehet≈ës√©g ‚Äì adat adapter injekt√°l√°sa query-re
Ez a logika t√©nyleg j√≥ helyre ker√ºlhet m√°r a query-n√©l, p√©ld√°ul a categoriesQuery defini√°l√°sakor:

ts
M√°sol√°s
Szerkeszt√©s
categoriesQuery = {
    name: 'categories',
    queryFn: async () => {
        const raw = await fetchCategories();
        return buildCategoryTree(raw); // itt m√°r tree-t ad vissza
    }
}
Ekkor a komponens m√°r nem CategoryType[], hanem CategoryTreeNode[]-ot kap.


*/